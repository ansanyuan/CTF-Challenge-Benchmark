{
  "topic": "现有如下代码：\n```c\nint smb2_read(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_read_req *req;\n\tstruct smb2_read_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length, mincount;\n\tssize_t nbytes = 0, remain_bytes = 0;\n\tint err = 0;\n\tbool is_rdma_channel = false;\n\tunsigned int max_read_size = conn->vals->max_read_size;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\tvoid *aux_payload_buf;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe read request\\n\");\n\t\treturn smb2_read_pipe(work);\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t\twork->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\tis_rdma_channel = true;\n\t\tmax_read_size = get_smbd_max_read_write_size();\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->ReadChannelInfoOffset);\n\n\t\tif (ch_offset < offsetof(struct smb2_read_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->ReadChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to read : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\tmincount = le32_to_cpu(req->MinimumCount);\n\n\tif (length > max_read_size) {\n\t\tksmbd_debug(SMB, \"limiting read size to max size(%u)\\n\",\n\t\t\t    max_read_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"filename %pD, offset %lld, len %zu\\n\",\n\t\t    fp->filp, offset, length);\n\n\taux_payload_buf = kvzalloc(length, GFP_KERNEL);\n\tif (!aux_payload_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnbytes = ksmbd_vfs_read(work, fp, length, &offset, aux_payload_buf);\n\tif (nbytes < 0) {\n\t\terr = nbytes;\n\t\tgoto out;\n\t}\n\n\tif ((nbytes == 0 && length != 0) || nbytes < mincount) {\n\t\tkvfree(aux_payload_buf);\n\t\trsp->hdr.Status = STATUS_END_OF_FILE;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn 0;\n\t}\n\n\tksmbd_debug(SMB, \"nbytes %zu, offset %lld mincount %zu\\n\",\n\t\t    nbytes, offset, mincount);\n\n\tif (is_rdma_channel == true) {\n\t\t/* write data to the client using rdma channel */\n\t\tremain_bytes = smb2_read_rdma_channel(work, req,\n\t\t\t\t\t\t      aux_payload_buf,\n\t\t\t\t\t\t      nbytes);\n\t\tkvfree(aux_payload_buf);\n\t\taux_payload_buf = NULL;\n\t\tnbytes = 0;\n\t\tif (remain_bytes < 0) {\n\t\t\terr = (int)remain_bytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = cpu_to_le32(remain_bytes);\n\trsp->Flags = 0;\n\terr = ksmbd_iov_pin_rsp_read(work, (void *)rsp,\n\t\t\t\t     offsetof(struct smb2_read_rsp, Buffer),\n\t\t\t\t     aux_payload_buf, nbytes);\n\tif (err) {\n\t\tkvfree(aux_payload_buf);\n\t\tgoto out;\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\tif (err == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\telse if (err == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (err == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (err == -ESHARE)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\t\tsmb2_set_err_rsp(work);\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n```\n同时已知其`req`局部变量可被用户操纵，部分相关结构体定义如下\n```c\n/* SMB2 read request without RFC1001 length at the beginning */\nstruct smb2_read_req {\n\tstruct smb2_hdr hdr;\n\t__le16 StructureSize; /* Must be 49 */\n\t__u8   Padding; /* offset from start of SMB2 header to place read */\n\t__u8   Flags; /* MBZ unless SMB3.02 or later */\n\t__le32 Length;\n\t__le64 Offset;\n\t__u64  PersistentFileId;\n\t__u64  VolatileFileId;\n\t__le32 MinimumCount;\n\t__le32 Channel; /* MBZ except for SMB3 or later */\n\t__le32 RemainingBytes;\n\t__le16 ReadChannelInfoOffset;\n\t__le16 ReadChannelInfoLength;\n\t__u8   Buffer[];\n} __packed;\n\nstruct smb2_read_rsp {\n\tstruct smb2_hdr hdr;\n\t__le16 StructureSize; /* Must be 17 */\n\t__u8   DataOffset;\n\t__u8   Reserved;\n\t__le32 DataLength;\n\t__le32 DataRemaining;\n\t__le32 Flags;\n\t__u8   Buffer[];\n} __packed;\n\n/* one of these for every pending CIFS request at the connection */\nstruct ksmbd_work {\n\t/* Server corresponding to this mid */\n\tstruct ksmbd_conn               *conn;\n\tstruct ksmbd_session            *sess;\n\tstruct ksmbd_tree_connect       *tcon;\n\n\t/* Pointer to received SMB header */\n\tvoid                            *request_buf;\n\t/* Response buffer */\n\tvoid                            *response_buf;\n\n\tstruct list_head\t\taux_read_list;\n\n\tstruct kvec\t\t\t*iov;\n\tint\t\t\t\tiov_alloc_cnt;\n\tint\t\t\t\tiov_cnt;\n\tint\t\t\t\tiov_idx;\n\n\t/* Next cmd hdr in compound req buf*/\n\tint                             next_smb2_rcv_hdr_off;\n\t/* Next cmd hdr in compound rsp buf*/\n\tint                             next_smb2_rsp_hdr_off;\n\t/* Current cmd hdr in compound rsp buf*/\n\tint                             curr_smb2_rsp_hdr_off;\n\n\t/*\n\t * Current Local FID assigned compound response if SMB2 CREATE\n\t * command is present in compound request\n\t */\n\tu64\t\t\t\tcompound_fid;\n\tu64\t\t\t\tcompound_pfid;\n\tu64\t\t\t\tcompound_sid;\n\n\tconst struct cred\t\t*saved_cred;\n\n\t/* Number of granted credits */\n\tunsigned int\t\t\tcredits_granted;\n\n\t/* response smb header size */\n\tunsigned int                    response_sz;\n\n\tvoid\t\t\t\t*tr_buf;\n\n\tunsigned char\t\t\tstate;\n\t/* No response for cancelled request */\n\tbool                            send_no_response:1;\n\t/* Request is encrypted */\n\tbool                            encrypted:1;\n\t/* Is this SYNC or ASYNC ksmbd_work */\n\tbool                            asynchronous:1;\n\tbool                            need_invalidate_rkey:1;\n\n\tunsigned int                    remote_key;\n\t/* cancel works */\n\tint                             async_id;\n\tvoid                            **cancel_argv;\n\tvoid                            (*cancel_fn)(void **argv);\n\n\tstruct work_struct              work;\n\t/* List head at conn->requests */\n\tstruct list_head                request_entry;\n\t/* List head at conn->async_requests */\n\tstruct list_head                async_request_entry;\n\tstruct list_head                fp_entry;\n\tstruct list_head                interim_entry;\n};\n```\n\n现请审计代码，找出其潜在的安全问题\n",
  "checkpoint": [
    {
      "offset.*可.+负数": 0.5
    },
    {
      "越界.*读.*": 0.5
    }
  ],
  "matchingmethod": [
    "regex",
    "regex"
  ]
}
